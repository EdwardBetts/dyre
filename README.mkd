Dyre - A Dynamic Reconfiguration Library for Haskell
====================================================

Dyre implements a basic interface for dynamically recompiling Haskell programs
with new configurations. The inspiration for all this is, of course, Xmonad's
reconfiguration functionality. It is similar in usage to the HConf library
which was written for the Yi editor.

Basic Usage
-----------

The main interface to the Dyre library consists of three items: a datatype for
configuration data, a set of default values, and a function which makes that data
into an entry-point function.

A complete, working example can be seen here:

    -- DyreExample.hs --
    module DyreExample ( dyreExample, Config(..), defaultConf ) where

    import qualified Config.Dyre as Dyre

    data Config = Config { message :: String }
    defaultConf = Config "Hello, world!"
    confError (Config message) error = Config $ "Error:" ++ error ++ "\n" ++ message

    realMain (Config message) = do
        putStrLn "Entered Main Function"
        putStrLn message

    dyreExample = Dyre.wrapMain Dyre.defaultParams
        { Dyre.projectName  = "dyreExample"
        , Dyre.showError    = confError
        , Dyre.realMain     = realMain
        }

    -- Main.hs --
    import DyreExample
    main = dyreExample defaultConf

The function `dyreExample` which is obtained from the `wrapMain` function is the
new program entry point. When called with a configuration, it will hand off the
control to Dyre, which will proceed to recompile and run the custom configuration
as needed. Eventually, the flow of control will pass back into the `realMain`
function, at which time Dyre is completely out of the picture.

Restarting and Persistent State
-------------------------------

Restarting is handled by the `Config.Dyre.Relaunch` module. The important
functions are the `relaunchWithState`, and `restoreState` functions. Together,
they require that your state type be a member of the `Read` and `Show`
typeclasses.

State can be saved with the `relaunchWithState` function, which takes a state
and an optional list of arguments. The master binary will be executed with the
arguments after writing the state to disk.

State is restored with the `restoreState` function. The function takes a default
state, which is returned when there is no state saved to disk, and should only
be called once, as the state file is removed after that.
